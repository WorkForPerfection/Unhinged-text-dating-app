//important requirements:
1) You must not add any public member variables/functions to your derived classes. You may add private member variables/helper methods.
2) try out all special cases and draw diagram for RadixTree class.
3) Make sure to implement and test each class independently of the others that depend on it.
4) you may use only those STL containers that are explicitly permitted for each class.

//The apps basic functionalities:
1) support 100k users
2) for each user store a set of key-value pairs like: hobby->"nose hair braiding"
3) for each user's set of attribute pairs, need to translate them into a set of COMPATIBLE attribute-pairs (e.g. "habit"->"nose hair braiding", compatible with "physical appearance"->"long nose hair")
4) rank order all potential matches for a member by identifying the people with the most compatible attribute-value pairs to that member

//Class needing to implmenet:
Class #1: You need to build a class called PersonProfile that holds a person’s profile (i.e., their
name, email, and attributes).
Class #2: You need to build a class called MemberDatabase that can store at least 100k
person profiles and lets you obtain a profile based on a member’s email address, as well as
search for the set of members that have a particular attribute-value pair in their profile.
Class #3: You need to build a class called AttributeTranslator that can translate from an input
attribute to a set of compatible attributes.
Class #4: You need to build a class called MatchMaker that can find all relevant matches for a
given member based on their attribute-value pairs, the attribute-value pairs of the other
members, and a threshold indicating the minimum set of matching attributes.
Class #5: You need to build a class template called RadixTree that implements a radix tree - based map, capable of mapping std::strings to any data type.
* note that insertion, lookup, and deletion of string-value pairs in RadixTree is O(k) where k is the length of the key (string) - since k is considered a constant in the project, so all operations are equivalent to O(1).


//additional resources given:
1) map.cpp: test the program
2) provided.h: Contains a couple of struct definitions that are used in the interfaces of some of the classes you will write
3) member.txt: contains a list of members and their attribute-value pairs.
4) An attribute translator data file, called translator.txt, which contains a list of attributes and their translations (a dictionary).

//what to turn in:
You will write .h and .cpp files for each of the classes PersonProfile, MemberDatabase,
AttributeTranslator, and MatchMaker, and a .h file for RadixTree.

-------------------------------------------------------------------------------------------------
1) profile: 
You must build a class called PersonProfile which implements a member’s profile. A profile for a
given member includes the following items:
● A person’s name (e.g., David Sm0lbirg)
● A person’s email address (e.g., sm0lbirg@hotmail.com)
● One or more attribute-value pairs that describe the member, e.g., (“hobby”, “coding”)

restrictions:
● MUST be able to add and retrieve attribute-value pairs in better than O(N) time where N
is the number of attribute-value pairs stored in the object. So for example, O(log2 N)
would be acceptable. For big-O analysis purposes, you may assume that there's a
constant that all attribute lengths are less than.
● MUST use your RadixTree class to map attributes to values (for full credit) - but you can use a STL map to replace it when need to do key-value mapping in test process
● MUST NOT use any STL maps 
● MUST NOT add any new public member functions or variables (other than the given)
● MAY use the STL list, vector, set, and unordered_set classes
● MAY have any private member functions or variables you choose to add
----------------------------------------------------------------------------------------------------
2)  attribute translator:

restrictions:
● MUST be able to retrieve all related attribute-value pairs for a specified source attribute-value pair in better than O(N) time where N is the number of source attribute-value pairs
stored in the object. So for example, O(log2 N) would be acceptable (although you can
do much better). For big-O analysis purposes, you may assume that there's a CONSTANT that all attribute lengths are less than. You may also assume that the number of compatible pairs any attribute-value pair translates to is bounded by a CONSTANT (e.g., < 10 pairs).
● MUST use your RadixTree class to map source attribute-value information to compatible
attribute-values (for full credit)
● MUST NOT use the STL map, unordered_map, multimap, or unordered_multimap types
● MUST NOT add any new public member functions or variables
● MAY use the STL list, vector, set, and unordered_set classes
● MAY have any private member functions or variables you choose to add

functions:

AttributeTranslator()
This is the AttributeTranslator constructor. It must take no arguments.

~AttributeTranslator()

bool Load(std::string filename);
This method loads the attribute-value translation data from the data file specified by the
filename parameter. The method must load the data into a data structure that enables efficient
translation of attribute-value pairs (meeting the big-O requirements at the top of this section).
The method must return true if the file was successfully loaded and false otherwise. You must ignore empty lines in datafile.

std::vector<AttValPair> FindCompatibleAttValPairs(const AttValPair& source) const;
This method must identify all compatible attribute-value pairs for the specified source attributevalue pair in an efficient manner (meeting the requirements at the top of this section) and return
a vector containing them. The vector returned must not contain two attribute-value pairs with the same attributes and values (i.e., no duplicates).

//idea: use a Radixtree in the form map<string,vector<AttValPair>> as the total dictionary that contains all compatibles for each source AttVal-pair string; build this dictionary in load file. Note that we can do this in O(N) since no restrictions are specified, by itearating through each source-target text in translator.txt, and create a AttValPair object for the target pair in each line, push the target into the source (in the form of a string like "hobby,climbing,")'s corresponding vector in map.
Then, we just need to return the value to the source attval-pair (key) in the map for get queries, which would cost O(k)=O(1) for a RadixTree map.

RadixTree: given a prefix, find all words in the dictionary (stored in a hashtable) with that prefix

----------------------------------------------------------------------------------------------------
RadixTree:
Notes:

The insert method must update the Radix Tree to associate the specified key string with a copy
of the passed-in value. Inserting the same item twice should simply replace the original value
with the new value. The insert method needs to consider a number of special cases and edge
conditions; here are a few to consider (this is not an exhaustive list of edge conditions).

e.g. insert 'he'->val1, then 'hello'->val2?
	 insert 'byte'->val3, and 'by'-> val4?

For this assignment, you may assume that the characters in a key string can be any character
encoded by an integer between 1 and 127, inclusive. You will not be expected to deal with
characters in your key strings whose encoding is outside that range. (Hint: It’s OK for each of
the nodes in your Radix Tree to have an array of roughly 128 pointers.)


ValueType* search(std::string key) const
The search method is responsible for searching your Radix Tree for the specified key. If the key
is found, then the search method must return a pointer to the value associated with the key. If
the specified key was not found, the method must return nullptr. If this method returns a non-null
pointer, the caller is free to modify the value held within the Radix Tree, e.g.:

RadixTree<AttValPair> rt;
... // insert a bunch of stuff into the radix tree rt
-------------------------------------------------------------------------------------------------------
Member Database:

MUST use your RadixTree class to map attribute-value pairs to email addresses.
MUST use your RadixTree class to map email addresses to member profiles.

restrictions:
1) You may assume that there are no extraneous spaces at the beginning or ending of any line, or
before or after any commas. The file may contain uppercase and lowercase letters. You may
assume that there’s a single empty line separating each member in the file. You can look at our
synthetically-generated members.txt file for an example of what you will have to parse.


//idea: iterate through the member textfile. Keep a private variable of a RadixTree<vector<string>> mp that maps a certain trait to a list of email addresses. Also keep another RadixTree<PersonProfile> mp2 that maps an email address to a person profile.
for each member, 
1) iterate through all his AVP (insert into mp with an empty vector<string> vec if neccessary), then pushback the current user's address in each AVP's corresponding vector
2) create a personprofile obj based on this person's profile; insert into mp2 "emailadd -> personprofile"

Then

------------------------------------------------------------------------------------------------------
MatchMaker:

Given a member’s email address, it must
look up the attribute-value pairs associated with that member (using the MemberDatabase and
PersonProfile classes), identify compatible attribute-value pairs (using the AttributeTranslator
class), and then identify and rank-order compatible members for the original member that have
at least the threshold number of compatible attributes. Finally, it must output these matching
members. 